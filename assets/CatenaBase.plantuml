@startuml
/'

Module:	CatenaBase.plantuml

Function:
	PlantUML reference source for README.md UML class diagram.
	
Copyright:
	See accompanying LICENSE file
	
Author:
	Terry Moore, MCCI Corporation	November 2018

Notes:
	PlantUML images in REAMDE.md are generated by pasting this file into
	the server at http://www.plantuml.com/plantuml, and grabbing the
	resulting URLs.  That has to be done several times, with different
	values edited into the variables below. The comments in README.md
	will tell you what's needed.

'/

!$enableMembers = 0
!$enableStm32 = 1
!$enableSamd = 0

namespace McciCatena {

abstract class CatenaBase {
  +struct EUI64_buffer_t;
  +struct EUI64_string_t;
  +struct UniqueID_buffer_t[];
  +struct UniqueID_string_t[];
  +enum OPERATING_FLAGS;
  +enum PLATFORM_FLAGS;
  +{static}uint32_t PlatformFlags_GetModNumber();
  +{static}bool constexpr PlatformFlags+_IsModded();
  +void SafePrintf();
  +const EUI64_Buffer_t *GetSysEUI();
  +{abstract}const CATENA_PLATFORM *GetPlatformForID();
  +{abstract}void GetUniqueID();
  +char *GetUniqueIDstring();
  +const CATENA_PLATFORM *GetPlatform();
  +uint32_t GetOperatingFlags();
  +void SetOperatingFlags();
  +uint32_t GetPlatformFlags();
  +{abstract}void begin();
  +{abstract}const char * CatenaName() const;
  +{abstract}void Sleep();
  +{abstract}cFram *getFram();
  +void poll();
  +void registerObject();
  +addCommands();
  +ProvisioningStyle GetProvisioningStyle();
  +bool GetAbpProvisioningInfo();
  +bool GetOtaaProvisioningInfo();
  +void NetSaveSessionInfo();
  +void NetSaveSessionState();
  +bool NetGetSessionInfo();
  +bool addLoRaWanCommands();
  +{static}CatenaBase *pCatenaBase;
  #{abstract}void registerCommands();
  #{abstract}void getPlatformTable();
  #{abstract}void getCpuIdPlatformTable();
  #cSerialReady	m_SerialReady;
  #EUI64_buffer_t m_SysEUI;
  #cPollingEngine m_PollingEnging;
  #cStreamInlineCollector m_Collector;
  #cCommandStream m_CommandStream;
  -uint32_t m_OperatingFlags;
  -const CATENA_PLATFORM *m_pPlatform;
  -void savePlatform();
  -void getPlatformForCpuId();
}
!if ($enableSamd == 1)
abstract class CatenaSamd21 {
  +{abstract} bool begin();
  +bool begin(uint32_t overrideMask);
  +book begin(uint32_t uClearMask, uint32_t uSetMask);
  +void GetUniqueID();
  +void Sleep();
  #{abstract}void registerCommands();
  -CatenaRTC m_Rtc;
}
!endif

!if ($enableStm32 == 1)
abstract class CatenaStm32 {
  +{abstract} bool begin();
  +bool begin(uint32_t overrideMask);
  +book begin(uint32_t uClearMask, uint32_t uSetMask);
  +void GetUniqueID();
  #{abstract}void registerCommands();
}
!endif

!if ($enableSamd == 1)
abstract class CatenaFeatherM0 {
  +enum ANALOG_PINS;
  +enum DIGITAL_PINS;
  +bool begin();
  +float ReadVbat() const;
  #{abstract}const ProvisioningInfo *GetProvisioningInfo();
  #{abstract}const ProvisioningTable *GetLoRaWANkeys();
}

abstract class CatenaWingFram2k {
  +enum ANALOG_PINS;
  +enum DIGITAL_PINS;
  +bool begin();
  +float ReadVbat() const;
  +cFram *getFram();
  +bool getBootCount(&bootCount);
  #void registerCommands();
  -cFram2k  m_Fram;
  -uint32_t m_BootCount;
}
!endif

!if ($enableStm32 == 1)
abstract class CatenaStm32L0 {
  +bool begin();
  +cFram *getFram();
  +bool getBootCount(&bootCount);
  +{abstract}float ReadVbat() const;
  +{abstract}float ReadVbus() const;
  +void Sleep();
  #void registerCommands();
  -cFram8k  m_Fram;
  -uint32_t m_BootCount;
  -CatenaStm32L0Rtc m_Rtc;
}


abstract class Catena455x {
  +enum ANALOG_PINS;
  +enum DIGITAL_PINS;
  +bool begin();
  +float ReadVbat() const;
  +float ReadVbus() const;
}

abstract class Catena461x {
  +enum ANALOG_PINS;
  +enum DIGITAL_PINS;
  +bool begin();
  +float ReadVbat() const;
  +float ReadVbus() const;
}

abstract class Catena463x {
  +enum ANALOG_PINS;
  +enum DIGITAL_PINS;
  +bool begin();
  +float ReadVbat() const;
  +float ReadVbus() const;
}

abstract class Catena480x {
  +enum ANALOG_PINS;
  +enum DIGITAL_PINS;
  +bool begin();
  +float ReadVbat() const;
  +float ReadVbus() const;
}
!endif

!if ($enableSamd == 1)
class Catena4410 {
  +enum DIGITAL_PINS;
  +const char *CatenaName() const;
  #const ProvisioningTable *GetLoRaWANkeys();
  #void getCpuIdPlatformTable();
  -{static}const ProvisioningTable gk_LoRaWAN_Keys;
  -{static}const CPUID_PLATFORM_MAP vCpuIdToPlatform[];
  -{static}const size_t nvCpuIdToPlatform;
}

class Catena4420 {
  +enum DIGITAL_PINS;
  +const char *CatenaName() const;
  #const ProvisioningTable *GetLoRaWANkeys();
  #void getCpuIdPlatformTable();
  -{static}const ProvisioningTable gk_LoRaWAN_Keys;
  -{static}const CPUID_PLATFORM_MAP vCpuIdToPlatform[];
  -{static}const size_t nvCpuIdToPlatform;
}

class Catena4450 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  #void getCpuIdPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
  -{static}const CPUID_PLATFORM_MAP vCpuIdToPlatform[];
  -{static}const size_t nvCpuIdToPlatform;
}

class Catena4460 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4470 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}
!endif

!if ($enableStm32 == 1)
class Catena4551 {
  +const char *CatenaName() const;
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4610 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4611 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4612 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4617 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4618 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4630 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4801 {
  +const char *CatenaName() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}

class Catena4802 {
  +const char *CatenaName() const;
  +float ReadVin() const;
  #void getPlatformTable();
  -{static}const CATENA_PLATFORM(* const vPlatforms[]);
  -{static}const size_t nvPlatforms;
}
!endif

!if ($enableSamd == 1)
CatenaBase <|-- CatenaSamd21
!endif

!if ($enableStm32 == 1)
CatenaBase <|-- CatenaStm32
!endif

!if ($enableSamd == 1)
CatenaSamd21 <|-- CatenaFeatherM0
CatenaSamd21 <|-- CatenaWingFram2k
CatenaFeatherM0 <|-- Catena4410
CatenaFeatherM0 <|-- Catena4420
CatenaWingFram2k <|-- Catena4450
CatenaWingFram2k <|-- Catena4460
CatenaWingFram2k <|-- Catena4470
!endif

!if ($enableStm32 == 1)
CatenaStm32 <|-- CatenaStm32L0
CatenaStm32L0 <|-- Catena455x
CatenaStm32L0 <|-- Catena461x
CatenaStm32L0 <|-- Catena463x
CatenaStm32L0 <|-- Catena480x

Catena455x <|-- Catena4551
Catena461x <|-- Catena4610
Catena461x <|-- Catena4611
Catena461x <|-- Catena4612
Catena461x <|-- Catena4617
Catena461x <|-- Catena4618
Catena463x <|-- Catena4630
Catena480x <|-- Catena4801
Catena480x <|-- Catena4802
!endif
}

!if ($enableMembers == 0)
hide members
!endif
@enduml